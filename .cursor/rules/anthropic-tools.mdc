---
description: Guía para usar Anthropic SDK con Tools y Agentic Loop. Aplicar cuando se creen agentes conversacionales, chat APIs, o se trabajen con tools de Claude.
alwaysApply: false
---

# Anthropic SDK - Tools & Agentic Loop

## Instalación

```bash
npm install @anthropic-ai/sdk
```

## Configuración inicial

```typescript
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic({ 
  apiKey: process.env.ANTHROPIC_CLAUDE_KEY 
})
```

## Definición de Tools

Las tools se definen con JSON Schema. Cada tool necesita:
- `name`: Nombre único (snake_case)
- `description`: Descripción clara de cuándo y cómo usarla
- `input_schema`: Schema JSON con properties y required

```typescript
const TOOLS: Anthropic.Tool[] = [
  {
    name: 'buscar_empleado',
    description: 'Busca empleados por nombre, legajo o sector. Usá esta tool cuando mencionen un empleado.',
    input_schema: {
      type: 'object',
      properties: {
        nombre: { 
          type: 'string', 
          description: 'Nombre o apellido del empleado' 
        },
        legajo: { 
          type: 'string', 
          description: 'Legajo del empleado (exacto)' 
        },
        sector: { 
          type: 'string', 
          description: 'Sector donde trabaja' 
        }
      },
      required: []  // Sin required = todos opcionales
    }
  },
  {
    name: 'asignar_turno',
    description: 'Asigna un turno a un empleado. Requiere legajo y turno_id.',
    input_schema: {
      type: 'object',
      properties: {
        legajo: { type: 'string', description: 'Legajo del empleado' },
        turno_id: { type: 'number', description: 'ID del turno a asignar' },
        fecha_desde: { type: 'string', description: 'Fecha desde (YYYY-MM-DD). Default: hoy' }
      },
      required: ['legajo', 'turno_id']
    }
  }
]
```

### Mejores prácticas para definir Tools

1. **Descripciones claras**: Indicar CUÁNDO usar la tool y QUÉ hace
2. **Descripciones en properties**: Cada property con descripción útil
3. **Formatos esperados**: Indicar formatos (ej: "HH:MM", "YYYY-MM-DD")
4. **Valores default**: Mencionar si hay defaults en la descripción
5. **Required mínimo**: Solo marcar required lo estrictamente necesario

## Agentic Loop (Patrón completo)

El patrón "Agentic Loop" permite que Claude use múltiples tools secuencialmente hasta completar la tarea:

```typescript
async function agenticLoop(
  messages: Anthropic.MessageParam[],
  systemPrompt: string,
  tools: Anthropic.Tool[],
  executeToolFn: (name: string, input: Record<string, unknown>) => Promise<string>
): Promise<{ text: string; toolCalls: Array<{ name: string; input: unknown; result: unknown }> }> {
  
  const currentMessages = [...messages]
  let finalText = ''
  const allToolCalls: Array<{ name: string; input: unknown; result: unknown }> = []
  let continueLoop = true

  while (continueLoop) {
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 16000,
      system: systemPrompt,
      messages: currentMessages,
      tools: tools,
    })

    // Procesar content blocks
    for (const block of response.content) {
      if (block.type === 'text') {
        finalText += block.text
      }
    }

    // Si stop_reason es 'tool_use', ejecutar tools y continuar
    if (response.stop_reason === 'tool_use') {
      const toolUses = response.content.filter(
        (block): block is Anthropic.ToolUseBlock => block.type === 'tool_use'
      )

      // Agregar respuesta del assistant al historial
      currentMessages.push({ role: 'assistant', content: response.content })

      // ⚡ Ejecutar TODAS las tools EN PARALELO
      const results = await Promise.all(
        toolUses.map(async (toolUse) => {
          const result = await executeToolFn(toolUse.name, toolUse.input as Record<string, unknown>)
          allToolCalls.push({ name: toolUse.name, input: toolUse.input, result })
          return { tool_use_id: toolUse.id, result }
        })
      )

      // Agregar resultados como mensaje 'user' con tool_result blocks
      currentMessages.push({
        role: 'user',
        content: results.map(r => ({
          type: 'tool_result' as const,
          tool_use_id: r.tool_use_id,
          content: typeof r.result === 'string' ? r.result : JSON.stringify(r.result)
        }))
      })

    } else {
      // stop_reason es 'end_turn' o 'max_tokens' - terminar loop
      continueLoop = false
    }
  }

  return { text: finalText, toolCalls: allToolCalls }
}
```

## Streaming con Tools

Para streaming, el patrón cambia ligeramente:

```typescript
const response = await anthropic.messages.create({
  model: 'claude-sonnet-4-20250514',
  max_tokens: 16000,
  system: SYSTEM_PROMPT,
  messages: currentMessages,
  tools: TOOLS,
  stream: true,  // ← Habilitar streaming
})

let currentText = ''
const toolUses: Array<{ id: string; name: string; input: Record<string, unknown> }> = []
let inputJsonBuffer = ''
let currentToolId = ''
let currentToolName = ''
let stopReason: string | null = null

for await (const event of response) {
  // Inicio de content block
  if (event.type === 'content_block_start') {
    if (event.content_block.type === 'tool_use') {
      currentToolId = event.content_block.id
      currentToolName = event.content_block.name
      inputJsonBuffer = ''
    }
  }

  // Delta de content
  if (event.type === 'content_block_delta') {
    const delta = event.delta

    if ('text' in delta && delta.text) {
      currentText += delta.text
      // Enviar texto al cliente (SSE, WebSocket, etc.)
    }

    if ('partial_json' in delta && delta.partial_json) {
      inputJsonBuffer += delta.partial_json
    }
  }

  // Fin de content block
  if (event.type === 'content_block_stop') {
    if (currentToolName) {
      const input = inputJsonBuffer ? JSON.parse(inputJsonBuffer) : {}
      toolUses.push({ id: currentToolId, name: currentToolName, input })
      currentToolId = ''
      currentToolName = ''
      inputJsonBuffer = ''
    }
  }

  // Fin del mensaje
  if (event.type === 'message_delta') {
    stopReason = event.delta.stop_reason
  }
}

// Si hay tools, ejecutarlas y continuar el loop
if (stopReason === 'tool_use' && toolUses.length > 0) {
  // ... ejecutar tools y seguir
}
```

## Historial de mensajes (CRÍTICO)

⚠️ **IMPORTANTE**: El historial DEBE incluir los bloques `tool_use` y `tool_result` completos, no solo texto.

### ❌ Incorrecto
```typescript
// Solo guardar role y contenido de texto pierde contexto de tools
messages.push({ role: 'assistant', content: 'Busqué al empleado...' })
```

### ✅ Correcto
```typescript
// Guardar el content completo incluyendo tool_use blocks
messages.push({
  role: 'assistant',
  content: [
    { type: 'text', text: 'Voy a buscar al empleado...' },
    { type: 'tool_use', id: 'toolu_123', name: 'buscar_empleado', input: { nombre: 'García' } }
  ]
})

// Guardar tool_result como mensaje user
messages.push({
  role: 'user',
  content: [
    { type: 'tool_result', tool_use_id: 'toolu_123', content: '{"id": 1, "nombre": "García"}' }
  ]
})
```

## Parallel Tool Calls (CRÍTICO para costos)

Claude puede llamar múltiples tools en una sola respuesta. **SIEMPRE** ejecutar en paralelo:

### ❌ Incorrecto (secuencial)
```typescript
for (const toolUse of toolUses) {
  const result = await executeToolFn(toolUse.name, toolUse.input)
  // Procesar resultado...
}
```

### ✅ Correcto (paralelo)
```typescript
const results = await Promise.all(
  toolUses.map(async (toolUse) => {
    const result = await executeToolFn(toolUse.name, toolUse.input)
    return { tool_use_id: toolUse.id, result }
  })
)
```

### Instruir a Claude en el System Prompt

```typescript
const SYSTEM_PROMPT = `
<parallel_tool_calls>
CRÍTICO: Cuando el usuario mencione MÚLTIPLES elementos o pida MÚLTIPLES operaciones:
- LLAMÁ TODAS las tools necesarias EN UNA SOLA RESPUESTA, no una por una.
- Ejemplo: Si dicen "buscar a García, López y Pérez", llamá buscar_empleado 3 veces EN PARALELO.
- NUNCA hagas una búsqueda, esperá respuesta, y luego otra búsqueda. Hacé TODAS juntas.
</parallel_tool_calls>
`
```

## Context Window Management

Para conversaciones largas, limitar el contexto:

```typescript
const MAX_MESSAGES = 20  // Ajustar según necesidad

let messagesToSend = [...allMessages]

if (messagesToSend.length > MAX_MESSAGES) {
  messagesToSend = messagesToSend.slice(-MAX_MESSAGES)
  
  // Agregar nota al system prompt
  systemPrompt += `\n\n<nota>
El historial fue truncado a los últimos ${MAX_MESSAGES} mensajes.
Usá las tools disponibles si necesitás información de contexto anterior.
</nota>`
}
```

## Debugging: Guardar Payload

Para debugging, guardar metadata de cada request:

```typescript
const requestPayload = {
  model: 'claude-sonnet-4-20250514',
  messages_count: currentMessages.length,
  messages_preview: currentMessages.map(m => ({
    role: m.role,
    content_length: typeof m.content === 'string' 
      ? m.content.length 
      : JSON.stringify(m.content).length
  })),
  tools_count: TOOLS.length,
  system_prompt_length: SYSTEM_PROMPT.length,
  timestamp: new Date().toISOString()
}

// Guardar en DB junto con el mensaje
await saveMessage(conversationId, 'assistant', text, toolCalls, {
  request_payload: requestPayload,
  response_info: { stop_reason, tool_calls_count: toolCalls.length }
})
```

## Estructura de tabla para mensajes

```sql
CREATE TABLE sicamar.messages (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id uuid REFERENCES sicamar.conversations(id),
  role text NOT NULL CHECK (role IN ('user', 'assistant')),
  content text NOT NULL,
  tool_calls jsonb,     -- Array de {name, input, result}
  metadata jsonb,       -- Para debugging: request_payload, response_info
  created_at timestamptz DEFAULT now()
);
```

## Ejemplo completo: API Route Next.js

```typescript
// /api/chat/route.ts
import { NextRequest } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_CLAUDE_KEY })

const TOOLS: Anthropic.Tool[] = [/* ... */]
const SYSTEM_PROMPT = `/* ... */`

async function executeTool(name: string, input: Record<string, unknown>): Promise<string> {
  // Implementación de cada tool
  switch (name) {
    case 'buscar_empleado':
      // ... lógica de búsqueda
      return JSON.stringify({ success: true, data: [...] })
    default:
      return JSON.stringify({ success: false, error: 'Tool no reconocida' })
  }
}

export async function POST(request: NextRequest) {
  const { message, history } = await request.json()

  const messages: Anthropic.MessageParam[] = [
    ...history,
    { role: 'user', content: message }
  ]

  const stream = new TransformStream()
  const writer = stream.writable.getWriter()
  const encoder = new TextEncoder()

  // Agentic loop async
  ;(async () => {
    try {
      const currentMessages = [...messages]
      let continueLoop = true

      while (continueLoop) {
        const response = await anthropic.messages.create({
          model: 'claude-sonnet-4-20250514',
          max_tokens: 16000,
          system: SYSTEM_PROMPT,
          messages: currentMessages,
          tools: TOOLS,
          stream: true,
        })

        // ... procesar streaming (ver sección anterior)

        if (stopReason === 'tool_use') {
          // Ejecutar tools en paralelo y agregar resultados
          // ... continuar loop
        } else {
          continueLoop = false
        }
      }

      await writer.write(encoder.encode('data: [DONE]\n\n'))
    } finally {
      await writer.close()
    }
  })()

  return new Response(stream.readable, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    }
  })
}
```

## Tool Runner (Módulo reutilizable)

El Tool Runner encapsula toda la lógica del agentic loop en una clase reutilizable:

```typescript
// lib/tool-runner.ts
import Anthropic from '@anthropic-ai/sdk'

export interface ToolDefinition {
  tool: Anthropic.Tool
  execute: (input: Record<string, unknown>) => Promise<string>
}

export interface ToolRunnerConfig {
  model?: string
  maxTokens?: number
  maxIterations?: number  // Límite de iteraciones del loop (seguridad)
}

export interface ToolRunnerResult {
  text: string
  toolCalls: Array<{ name: string; input: unknown; result: unknown }>
  stopReason: string | null
  iterations: number
}

export class ToolRunner {
  private anthropic: Anthropic
  private tools: Map<string, ToolDefinition>
  private config: Required<ToolRunnerConfig>

  constructor(
    apiKey: string,
    toolDefinitions: ToolDefinition[],
    config: ToolRunnerConfig = {}
  ) {
    this.anthropic = new Anthropic({ apiKey })
    this.tools = new Map(toolDefinitions.map(t => [t.tool.name, t]))
    this.config = {
      model: config.model || 'claude-sonnet-4-20250514',
      maxTokens: config.maxTokens || 16000,
      maxIterations: config.maxIterations || 10,
    }
  }

  /**
   * Ejecuta el agentic loop hasta que Claude termine o se alcance el límite
   */
  async run(
    systemPrompt: string,
    messages: Anthropic.MessageParam[]
  ): Promise<ToolRunnerResult> {
    const currentMessages = [...messages]
    let finalText = ''
    const allToolCalls: Array<{ name: string; input: unknown; result: unknown }> = []
    let iterations = 0
    let lastStopReason: string | null = null

    while (iterations < this.config.maxIterations) {
      iterations++

      const response = await this.anthropic.messages.create({
        model: this.config.model,
        max_tokens: this.config.maxTokens,
        system: systemPrompt,
        messages: currentMessages,
        tools: Array.from(this.tools.values()).map(t => t.tool),
      })

      lastStopReason = response.stop_reason

      // Extraer texto
      for (const block of response.content) {
        if (block.type === 'text') {
          finalText += block.text
        }
      }

      // Si no hay tool_use, terminamos
      if (response.stop_reason !== 'tool_use') {
        break
      }

      // Extraer tool uses
      const toolUses = response.content.filter(
        (b): b is Anthropic.ToolUseBlock => b.type === 'tool_use'
      )

      if (toolUses.length === 0) break

      // Agregar respuesta del assistant al historial
      currentMessages.push({ role: 'assistant', content: response.content })

      // Ejecutar TODAS las tools EN PARALELO
      const results = await Promise.all(
        toolUses.map(async (toolUse) => {
          const toolDef = this.tools.get(toolUse.name)
          if (!toolDef) {
            return {
              tool_use_id: toolUse.id,
              name: toolUse.name,
              input: toolUse.input,
              result: JSON.stringify({ error: `Tool "${toolUse.name}" not found` }),
            }
          }

          try {
            const result = await toolDef.execute(toolUse.input as Record<string, unknown>)
            return { tool_use_id: toolUse.id, name: toolUse.name, input: toolUse.input, result }
          } catch (error) {
            return {
              tool_use_id: toolUse.id,
              name: toolUse.name,
              input: toolUse.input,
              result: JSON.stringify({ error: error instanceof Error ? error.message : 'Unknown error' }),
            }
          }
        })
      )

      // Agregar resultados al historial
      currentMessages.push({
        role: 'user',
        content: results.map(r => ({
          type: 'tool_result' as const,
          tool_use_id: r.tool_use_id,
          content: r.result,
        })),
      })

      // Track tool calls
      for (const r of results) {
        allToolCalls.push({ name: r.name, input: r.input, result: r.result })
      }
    }

    return {
      text: finalText,
      toolCalls: allToolCalls,
      stopReason: lastStopReason,
      iterations,
    }
  }

  /**
   * Versión con streaming - retorna un ReadableStream para SSE
   */
  runStream(
    systemPrompt: string,
    messages: Anthropic.MessageParam[],
    onToolCall?: (name: string, input: unknown) => void,
    onToolResult?: (name: string, result: unknown) => void
  ): ReadableStream<Uint8Array> {
    const encoder = new TextEncoder()
    const runner = this

    return new ReadableStream({
      async start(controller) {
        const currentMessages = [...messages]
        let iterations = 0

        try {
          while (iterations < runner.config.maxIterations) {
            iterations++

            const response = await runner.anthropic.messages.create({
              model: runner.config.model,
              max_tokens: runner.config.maxTokens,
              system: systemPrompt,
              messages: currentMessages,
              tools: Array.from(runner.tools.values()).map(t => t.tool),
              stream: true,
            })

            let currentText = ''
            const toolUses: Array<{ id: string; name: string; input: Record<string, unknown> }> = []
            let inputJsonBuffer = ''
            let currentToolId = ''
            let currentToolName = ''
            let stopReason: string | null = null

            for await (const event of response) {
              if (event.type === 'content_block_start') {
                if (event.content_block.type === 'tool_use') {
                  currentToolId = event.content_block.id
                  currentToolName = event.content_block.name
                  inputJsonBuffer = ''
                }
              }

              if (event.type === 'content_block_delta') {
                const delta = event.delta
                if ('text' in delta && delta.text) {
                  currentText += delta.text
                  controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: 'text', content: delta.text })}\n\n`))
                }
                if ('partial_json' in delta && delta.partial_json) {
                  inputJsonBuffer += delta.partial_json
                }
              }

              if (event.type === 'content_block_stop') {
                if (currentToolName) {
                  const input = inputJsonBuffer ? JSON.parse(inputJsonBuffer) : {}
                  toolUses.push({ id: currentToolId, name: currentToolName, input })
                  controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: 'tool_call', name: currentToolName, input })}\n\n`))
                  onToolCall?.(currentToolName, input)
                  currentToolId = ''
                  currentToolName = ''
                  inputJsonBuffer = ''
                }
              }

              if (event.type === 'message_delta') {
                stopReason = event.delta.stop_reason
              }
            }

            // Si no hay tool_use, terminamos
            if (stopReason !== 'tool_use' || toolUses.length === 0) {
              break
            }

            // Agregar assistant message al historial
            currentMessages.push({
              role: 'assistant',
              content: [
                ...(currentText ? [{ type: 'text' as const, text: currentText }] : []),
                ...toolUses.map(tu => ({
                  type: 'tool_use' as const,
                  id: tu.id,
                  name: tu.name,
                  input: tu.input,
                })),
              ],
            })

            // Ejecutar tools en paralelo
            const results = await Promise.all(
              toolUses.map(async (toolUse) => {
                const toolDef = runner.tools.get(toolUse.name)
                if (!toolDef) {
                  return { id: toolUse.id, name: toolUse.name, result: JSON.stringify({ error: 'Tool not found' }) }
                }
                try {
                  const result = await toolDef.execute(toolUse.input)
                  return { id: toolUse.id, name: toolUse.name, result }
                } catch (error) {
                  return { id: toolUse.id, name: toolUse.name, result: JSON.stringify({ error: String(error) }) }
                }
              })
            )

            // Enviar resultados y agregar al historial
            for (const r of results) {
              controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: 'tool_result', name: r.name, result: r.result })}\n\n`))
              onToolResult?.(r.name, r.result)
            }

            currentMessages.push({
              role: 'user',
              content: results.map(r => ({
                type: 'tool_result' as const,
                tool_use_id: r.id,
                content: r.result,
              })),
            })
          }

          controller.enqueue(encoder.encode('data: [DONE]\n\n'))
        } catch (error) {
          controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: 'error', message: String(error) })}\n\n`))
        } finally {
          controller.close()
        }
      },
    })
  }
}
```

### Uso del Tool Runner

```typescript
// Definir tools con sus ejecutores
const toolDefinitions: ToolDefinition[] = [
  {
    tool: {
      name: 'buscar_empleado',
      description: 'Busca empleados por nombre',
      input_schema: {
        type: 'object',
        properties: {
          query: { type: 'string', description: 'Nombre a buscar' }
        },
        required: ['query']
      }
    },
    execute: async (input) => {
      const { query } = input as { query: string }
      // Lógica de búsqueda...
      return JSON.stringify({ success: true, data: [{ id: 1, nombre: query }] })
    }
  },
  {
    tool: {
      name: 'asignar_turno',
      description: 'Asigna turno a empleado',
      input_schema: {
        type: 'object',
        properties: {
          empleado_id: { type: 'number' },
          turno: { type: 'string', enum: ['mañana', 'tarde', 'noche'] }
        },
        required: ['empleado_id', 'turno']
      }
    },
    execute: async (input) => {
      const { empleado_id, turno } = input as { empleado_id: number; turno: string }
      // Lógica de asignación...
      return JSON.stringify({ success: true, message: `Turno ${turno} asignado a empleado ${empleado_id}` })
    }
  }
]

// Crear instancia del runner
const runner = new ToolRunner(
  process.env.ANTHROPIC_CLAUDE_KEY!,
  toolDefinitions,
  { model: 'claude-sonnet-4-20250514', maxIterations: 5 }
)

// Uso sin streaming
const result = await runner.run(SYSTEM_PROMPT, [
  { role: 'user', content: 'Buscá a García y asignale turno mañana' }
])
console.log(result.text)
console.log(result.toolCalls)

// Uso con streaming (para API routes)
export async function POST(request: NextRequest) {
  const { message } = await request.json()
  
  const stream = runner.runStream(
    SYSTEM_PROMPT,
    [{ role: 'user', content: message }],
    (name, input) => console.log('Tool called:', name, input),
    (name, result) => console.log('Tool result:', name, result)
  )
  
  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
    }
  })
}
```

### Tool Runner con MCP (Model Context Protocol)

Si tus tools están expuestas via MCP, podés crear un adapter:

```typescript
// lib/mcp-tool-runner.ts
import { ToolRunner, ToolDefinition } from './tool-runner'

interface McpToolConfig {
  name: string
  mcpToolName: string  // Nombre en el MCP (ej: 'sicamar.empleados.buscar')
  description: string
  inputSchema: Record<string, unknown>
}

async function callMcp(toolName: string, input: Record<string, unknown>): Promise<string> {
  const response = await fetch(`${process.env.MCP_BASE_URL}/tools/call`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${await generateMcpToken()}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ tool: toolName, input })
  })
  
  const result = await response.json()
  return typeof result === 'string' ? result : JSON.stringify(result)
}

export function createMcpToolRunner(
  apiKey: string,
  mcpTools: McpToolConfig[]
): ToolRunner {
  const toolDefinitions: ToolDefinition[] = mcpTools.map(t => ({
    tool: {
      name: t.name,
      description: t.description,
      input_schema: t.inputSchema
    },
    execute: (input) => callMcp(t.mcpToolName, input)
  }))
  
  return new ToolRunner(apiKey, toolDefinitions)
}

// Uso
const runner = createMcpToolRunner(process.env.ANTHROPIC_CLAUDE_KEY!, [
  {
    name: 'sicamar_empleados_buscar',
    mcpToolName: 'sicamar.empleados.buscar',
    description: 'Busca empleados por nombre',
    inputSchema: { type: 'object', properties: { query: { type: 'string' } }, required: ['query'] }
  },
  // ... más tools
])
```

## Checklist de implementación

- [ ] Tools definidas con descripciones claras y JSON Schema correcto
- [ ] ToolRunner instanciado con todas las tools y sus ejecutores
- [ ] maxIterations configurado para evitar loops infinitos
- [ ] Ejecución de tools en PARALELO con `Promise.all()`
- [ ] Historial incluye bloques `tool_use` y `tool_result` completos
- [ ] System prompt instruye parallel tool calls
- [ ] Context window limitado para conversaciones largas
- [ ] Metadata de debugging guardada en cada mensaje
- [ ] SSE/streaming correctamente implementado via `runStream()`
