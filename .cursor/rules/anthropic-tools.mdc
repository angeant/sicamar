---
description: Guía para usar Anthropic SDK con Tools y Agentic Loop. Aplicar cuando se creen agentes conversacionales, chat APIs, o se trabajen con tools de Claude.
alwaysApply: false
---

# Anthropic SDK - Tools & Agentic Loop

## Instalación

```bash
npm install @anthropic-ai/sdk
```

## Configuración inicial

```typescript
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic({ 
  apiKey: process.env.ANTHROPIC_CLAUDE_KEY 
})
```

## Definición de Tools

Las tools se definen con JSON Schema. Cada tool necesita:
- `name`: Nombre único (snake_case)
- `description`: Descripción clara de cuándo y cómo usarla
- `input_schema`: Schema JSON con properties y required

```typescript
const TOOLS: Anthropic.Tool[] = [
  {
    name: 'buscar_empleado',
    description: 'Busca empleados por nombre, legajo o sector. Usá esta tool cuando mencionen un empleado.',
    input_schema: {
      type: 'object',
      properties: {
        nombre: { 
          type: 'string', 
          description: 'Nombre o apellido del empleado' 
        },
        legajo: { 
          type: 'string', 
          description: 'Legajo del empleado (exacto)' 
        },
        sector: { 
          type: 'string', 
          description: 'Sector donde trabaja' 
        }
      },
      required: []  // Sin required = todos opcionales
    }
  },
  {
    name: 'asignar_turno',
    description: 'Asigna un turno a un empleado. Requiere legajo y turno_id.',
    input_schema: {
      type: 'object',
      properties: {
        legajo: { type: 'string', description: 'Legajo del empleado' },
        turno_id: { type: 'number', description: 'ID del turno a asignar' },
        fecha_desde: { type: 'string', description: 'Fecha desde (YYYY-MM-DD). Default: hoy' }
      },
      required: ['legajo', 'turno_id']
    }
  }
]
```

### Mejores prácticas para definir Tools

1. **Descripciones claras**: Indicar CUÁNDO usar la tool y QUÉ hace
2. **Descripciones en properties**: Cada property con descripción útil
3. **Formatos esperados**: Indicar formatos (ej: "HH:MM", "YYYY-MM-DD")
4. **Valores default**: Mencionar si hay defaults en la descripción
5. **Required mínimo**: Solo marcar required lo estrictamente necesario

## Agentic Loop (Patrón completo)

El patrón "Agentic Loop" permite que Claude use múltiples tools secuencialmente hasta completar la tarea:

```typescript
async function agenticLoop(
  messages: Anthropic.MessageParam[],
  systemPrompt: string,
  tools: Anthropic.Tool[],
  executeToolFn: (name: string, input: Record<string, unknown>) => Promise<string>
): Promise<{ text: string; toolCalls: Array<{ name: string; input: unknown; result: unknown }> }> {
  
  const currentMessages = [...messages]
  let finalText = ''
  const allToolCalls: Array<{ name: string; input: unknown; result: unknown }> = []
  let continueLoop = true

  while (continueLoop) {
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 16000,
      system: systemPrompt,
      messages: currentMessages,
      tools: tools,
    })

    // Procesar content blocks
    for (const block of response.content) {
      if (block.type === 'text') {
        finalText += block.text
      }
    }

    // Si stop_reason es 'tool_use', ejecutar tools y continuar
    if (response.stop_reason === 'tool_use') {
      const toolUses = response.content.filter(
        (block): block is Anthropic.ToolUseBlock => block.type === 'tool_use'
      )

      // Agregar respuesta del assistant al historial
      currentMessages.push({ role: 'assistant', content: response.content })

      // ⚡ Ejecutar TODAS las tools EN PARALELO
      const results = await Promise.all(
        toolUses.map(async (toolUse) => {
          const result = await executeToolFn(toolUse.name, toolUse.input as Record<string, unknown>)
          allToolCalls.push({ name: toolUse.name, input: toolUse.input, result })
          return { tool_use_id: toolUse.id, result }
        })
      )

      // Agregar resultados como mensaje 'user' con tool_result blocks
      currentMessages.push({
        role: 'user',
        content: results.map(r => ({
          type: 'tool_result' as const,
          tool_use_id: r.tool_use_id,
          content: typeof r.result === 'string' ? r.result : JSON.stringify(r.result)
        }))
      })

    } else {
      // stop_reason es 'end_turn' o 'max_tokens' - terminar loop
      continueLoop = false
    }
  }

  return { text: finalText, toolCalls: allToolCalls }
}
```

## Streaming con Tools

Para streaming, el patrón cambia ligeramente:

```typescript
const response = await anthropic.messages.create({
  model: 'claude-sonnet-4-20250514',
  max_tokens: 16000,
  system: SYSTEM_PROMPT,
  messages: currentMessages,
  tools: TOOLS,
  stream: true,  // ← Habilitar streaming
})

let currentText = ''
const toolUses: Array<{ id: string; name: string; input: Record<string, unknown> }> = []
let inputJsonBuffer = ''
let currentToolId = ''
let currentToolName = ''
let stopReason: string | null = null

for await (const event of response) {
  // Inicio de content block
  if (event.type === 'content_block_start') {
    if (event.content_block.type === 'tool_use') {
      currentToolId = event.content_block.id
      currentToolName = event.content_block.name
      inputJsonBuffer = ''
    }
  }

  // Delta de content
  if (event.type === 'content_block_delta') {
    const delta = event.delta

    if ('text' in delta && delta.text) {
      currentText += delta.text
      // Enviar texto al cliente (SSE, WebSocket, etc.)
    }

    if ('partial_json' in delta && delta.partial_json) {
      inputJsonBuffer += delta.partial_json
    }
  }

  // Fin de content block
  if (event.type === 'content_block_stop') {
    if (currentToolName) {
      const input = inputJsonBuffer ? JSON.parse(inputJsonBuffer) : {}
      toolUses.push({ id: currentToolId, name: currentToolName, input })
      currentToolId = ''
      currentToolName = ''
      inputJsonBuffer = ''
    }
  }

  // Fin del mensaje
  if (event.type === 'message_delta') {
    stopReason = event.delta.stop_reason
  }
}

// Si hay tools, ejecutarlas y continuar el loop
if (stopReason === 'tool_use' && toolUses.length > 0) {
  // ... ejecutar tools y seguir
}
```

## Historial de mensajes (CRÍTICO)

⚠️ **IMPORTANTE**: El historial DEBE incluir los bloques `tool_use` y `tool_result` completos, no solo texto.

### ❌ Incorrecto
```typescript
// Solo guardar role y contenido de texto pierde contexto de tools
messages.push({ role: 'assistant', content: 'Busqué al empleado...' })
```

### ✅ Correcto
```typescript
// Guardar el content completo incluyendo tool_use blocks
messages.push({
  role: 'assistant',
  content: [
    { type: 'text', text: 'Voy a buscar al empleado...' },
    { type: 'tool_use', id: 'toolu_123', name: 'buscar_empleado', input: { nombre: 'García' } }
  ]
})

// Guardar tool_result como mensaje user
messages.push({
  role: 'user',
  content: [
    { type: 'tool_result', tool_use_id: 'toolu_123', content: '{"id": 1, "nombre": "García"}' }
  ]
})
```

## Parallel Tool Calls (CRÍTICO para costos)

Claude puede llamar múltiples tools en una sola respuesta. **SIEMPRE** ejecutar en paralelo:

### ❌ Incorrecto (secuencial)
```typescript
for (const toolUse of toolUses) {
  const result = await executeToolFn(toolUse.name, toolUse.input)
  // Procesar resultado...
}
```

### ✅ Correcto (paralelo)
```typescript
const results = await Promise.all(
  toolUses.map(async (toolUse) => {
    const result = await executeToolFn(toolUse.name, toolUse.input)
    return { tool_use_id: toolUse.id, result }
  })
)
```

### Instruir a Claude en el System Prompt

```typescript
const SYSTEM_PROMPT = `
<parallel_tool_calls>
CRÍTICO: Cuando el usuario mencione MÚLTIPLES elementos o pida MÚLTIPLES operaciones:
- LLAMÁ TODAS las tools necesarias EN UNA SOLA RESPUESTA, no una por una.
- Ejemplo: Si dicen "buscar a García, López y Pérez", llamá buscar_empleado 3 veces EN PARALELO.
- NUNCA hagas una búsqueda, esperá respuesta, y luego otra búsqueda. Hacé TODAS juntas.
</parallel_tool_calls>
`
```

## Context Window Management

Para conversaciones largas, limitar el contexto:

```typescript
const MAX_MESSAGES = 20  // Ajustar según necesidad

let messagesToSend = [...allMessages]

if (messagesToSend.length > MAX_MESSAGES) {
  messagesToSend = messagesToSend.slice(-MAX_MESSAGES)
  
  // Agregar nota al system prompt
  systemPrompt += `\n\n<nota>
El historial fue truncado a los últimos ${MAX_MESSAGES} mensajes.
Usá las tools disponibles si necesitás información de contexto anterior.
</nota>`
}
```

## Debugging: Guardar Payload

Para debugging, guardar metadata de cada request:

```typescript
const requestPayload = {
  model: 'claude-sonnet-4-20250514',
  messages_count: currentMessages.length,
  messages_preview: currentMessages.map(m => ({
    role: m.role,
    content_length: typeof m.content === 'string' 
      ? m.content.length 
      : JSON.stringify(m.content).length
  })),
  tools_count: TOOLS.length,
  system_prompt_length: SYSTEM_PROMPT.length,
  timestamp: new Date().toISOString()
}

// Guardar en DB junto con el mensaje
await saveMessage(conversationId, 'assistant', text, toolCalls, {
  request_payload: requestPayload,
  response_info: { stop_reason, tool_calls_count: toolCalls.length }
})
```

## Estructura de tabla para mensajes

```sql
CREATE TABLE sicamar.messages (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id uuid REFERENCES sicamar.conversations(id),
  role text NOT NULL CHECK (role IN ('user', 'assistant')),
  content text NOT NULL,
  tool_calls jsonb,     -- Array de {name, input, result}
  metadata jsonb,       -- Para debugging: request_payload, response_info
  created_at timestamptz DEFAULT now()
);
```

## Ejemplo completo: API Route Next.js

```typescript
// /api/chat/route.ts
import { NextRequest } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_CLAUDE_KEY })

const TOOLS: Anthropic.Tool[] = [/* ... */]
const SYSTEM_PROMPT = `/* ... */`

async function executeTool(name: string, input: Record<string, unknown>): Promise<string> {
  // Implementación de cada tool
  switch (name) {
    case 'buscar_empleado':
      // ... lógica de búsqueda
      return JSON.stringify({ success: true, data: [...] })
    default:
      return JSON.stringify({ success: false, error: 'Tool no reconocida' })
  }
}

export async function POST(request: NextRequest) {
  const { message, history } = await request.json()

  const messages: Anthropic.MessageParam[] = [
    ...history,
    { role: 'user', content: message }
  ]

  const stream = new TransformStream()
  const writer = stream.writable.getWriter()
  const encoder = new TextEncoder()

  // Agentic loop async
  ;(async () => {
    try {
      const currentMessages = [...messages]
      let continueLoop = true

      while (continueLoop) {
        const response = await anthropic.messages.create({
          model: 'claude-sonnet-4-20250514',
          max_tokens: 16000,
          system: SYSTEM_PROMPT,
          messages: currentMessages,
          tools: TOOLS,
          stream: true,
        })

        // ... procesar streaming (ver sección anterior)

        if (stopReason === 'tool_use') {
          // Ejecutar tools en paralelo y agregar resultados
          // ... continuar loop
        } else {
          continueLoop = false
        }
      }

      await writer.write(encoder.encode('data: [DONE]\n\n'))
    } finally {
      await writer.close()
    }
  })()

  return new Response(stream.readable, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    }
  })
}
```

## Checklist de implementación

- [ ] Tools definidas con descripciones claras y JSON Schema correcto
- [ ] Agentic loop que continúa mientras `stop_reason === 'tool_use'`
- [ ] Ejecución de tools en PARALELO con `Promise.all()`
- [ ] Historial incluye bloques `tool_use` y `tool_result` completos
- [ ] System prompt instruye parallel tool calls
- [ ] Context window limitado para conversaciones largas
- [ ] Metadata de debugging guardada en cada mensaje
- [ ] SSE/streaming correctamente implementado
